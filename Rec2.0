import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.neighbors import NearestNeighbors
from sklearn.model_selection import train_test_split
from sklearn.metrics import precision_score, recall_score
 
# Load data
movies = pd.read_csv('data.csv')
 
# Select relevant columns
new_movies = movies[['id', 'title', 'genre', 'overview']]
 
# Drop rows with missing values
df = new_movies.dropna(subset=['genre', 'overview'])
 
# Combine 'genre' and 'overview' into a single text feature
df['tag'] = df['genre'].str.cat(df['overview'], sep=' ')
 
# Drop original columns 'genre' and 'overview'
df = df.drop(columns=['genre', 'overview'])
 
# Split the data into training and test sets
train_df, test_df = train_test_split(df, test_size=0.2, random_state=42)
 
# Vectorize the combined text feature for training data
vectorizer = TfidfVectorizer()
tfidf_matrix_train = vectorizer.fit_transform(train_df['tag'])
tfidf_matrix_test = vectorizer.transform(test_df['tag'])
 
# Initialize the k-NN model
knn = NearestNeighbors(n_neighbors=5, metric='cosine')
knn.fit(tfidf_matrix_train)
 
# Function to get recommendations using KNN
def get_knn_recommendations(movie_vector, knn, top_n=5):
    distances, indices = knn.kneighbors(movie_vector, n_neighbors=top_n)
    return indices[0]
 
# Evaluate recommendations
def evaluate_recommendations(test_df, train_df, knn, vectorizer):
    y_true = []
    y_pred = []
 
    for idx, row in test_df.iterrows():
        # Ensure 'title' is in train_df before proceeding
        if row['title'] in train_df['title'].values:
            # Get the index of the movie in train_df
            movie_index = train_df[train_df['title'] == row['title']].index[0]
            # Check if idx is within the range of tfidf_matrix_test
            if idx < tfidf_matrix_test.shape[0]:
                movie_vector = tfidf_matrix_test[idx]
                recommended_indices = get_knn_recommendations(movie_vector, knn)
                recommended_titles = train_df.iloc[recommended_indices]['title'].tolist()
                relevant_items = [row['title']]
                recommended_items = [train_df.iloc[i]['title'] for i in recommended_indices]
                y_true.extend([1 if item in relevant_items else 0 for item in recommended_items])
                y_pred.extend([1 if item in relevant_items else 0 for item in recommended_items])
    # Calculate precision and recall with zero_division=0 to avoid ZeroDivisionError
    precision = precision_score(y_true, y_pred, average='binary', zero_division=0)
    recall = recall_score(y_true, y_pred, average='binary', zero_division=0)
    return precision, recall
 
# Perform evaluation
precision, recall = evaluate_recommendations(test_df, train_df, knn, vectorizer)
 
# Print results
print(f"Precision: {precision:.2f}")
print(f"Recall: {recall:.2f}")
